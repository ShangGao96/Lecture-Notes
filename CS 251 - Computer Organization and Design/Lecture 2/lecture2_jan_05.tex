\documentclass{report}
\usepackage[margin=1in, paperwidth=8.5in, paperheight=11in]{geometry}
%Math packages%
\usepackage{amsmath}
\usepackage{amsthm}
%Spacing%
\usepackage{setspace}
\onehalfspacing
%Lecture number%
\newcommand{\lectureNum}{2}
%Variables - Date and Course%
\newcommand{\curDate}{January 5, 2017}
\newcommand{\course}{CS 251}
\newcommand{\instructor}{Stephen Mann}
%Defining the example tag%
%\theoremstyle{definition}%
\newtheorem{ex}{Example}[section]
%Setting counter given the lecture number%
\setcounter{chapter}{\lectureNum{}}
%Package to insert code%
\usepackage{listings}
\usepackage{courier}
\usepackage{xcolor}
\lstset { %
    tabsize=2,
    breaklines=true,
    language=C++,
    backgroundcolor=\color{blue!8}, % set backgroundcolor
    basicstyle=\footnotesize\ttfamily,% basic font setting
}
\begin{document}
%Note title%
\begin{center}
\begin{Large}
\textsc{\course{} | Lecture \lectureNum{}}
\end{Large}
\end{center} 
\noindent \textit{Bartosz Antczak} \hfill
\textit{Instructor: \instructor{}} \hfill
\textit{\curDate{}}
\rule{\textwidth}{0.4pt}
% Actual Notes%
\section{Computer performance}
When measuring computer performance, we focus on two factors:
\begin{itemize}
\item \textit{Response time:} time between the start and completion of a task. Some factors that affect this include the speed of the computer's clock, complexity of the instruction set, and the efficiency of compilers
\item \textit{Throughput:} the total amount of work done in a given time
\end{itemize}
Despite this, it isn't easy to measure computer performance accurately.
\subsubsection{Clock speed}
Clock speed is measured in Hertz (Hz). Faster clock speed means more instructions executed per second, and one instruction is executed per clock cycle.
\subsubsection{Comparing speeds of computers}
We can use benchmarks (which are a standard set of programs and data chosen to measure performance) as a basis to compare the speeds of different computers.
\subsection{Logic blocks}
We have two types:
\begin{itemize}
\item Combinational (without memory): takes in $n$ inputs and runs them through a combinational circuit and produces $m$ outputs
\item Sequential (with memory): takes in inputs, runs through a combinational circuit and outputs some output and stores the rest in storage
\end{itemize}
\subsection{Specifying input/output behaviour}
We use truth tables to specify outputs for each possible input combination.
\subsubsection{Boolean algebra}
In our truth tables, we'll be working with OR (+), AND ($\cdot$), and NOT ($\neg$):
\begin{itemize}
\item OR: has result 1 if and only if either operand has value 1
\item AND: has result 1 if and only if both operands have value 1 ($A \cdot B$ is often written as $AB$)
\item NOT: negates the operand (0 becomes 1, and 1 becomes 0) 
\end{itemize} \newpage
\begin{ex}
The truth table for AND with two variables
\end{ex}
\begin{center}
\begin{tabular}{ | c | c | c | }
\hline A & B & AB \\ \hline
0 & 0 & 0 \\ \hline
0 & 1 & 0 \\ \hline
1 & 0 & 0 \\ \hline
1 & 1 & 1 \\ \hline
\end{tabular}
\end{center}
%^^ Will be on assignments and midterm (easy marks!)%
These variables (i.e., $A$, $\bar{A}$) are called \textit{literals}.\\
A conjunction of literals (i.e., $A\bar{B}C$) is called a \textit{minterm}, and a disjunction of literals (i.e., $A+B$) is called a \textit{maxterm}.\\
In these truth tables, any Boolean function can be represented as a sum of products (OR of ANDs) of literals.
\subsubsection{Don't cares in truth tables}
For outputs that we don't care what value it has, we represent them with an `X'. For instance, if we apply function $F$ on literals $A$, $B$, $C$
\begin{center}
\begin{tabular}{ c | c | c | c }
\textbf{A} & \textbf{B} & \textbf{C} & \textbf{F}\\ \hline
0 & 0 & X & 0 \\ \hline
0 & 1 & X & 1 \\ \hline
1 & X & X & X \\
\end{tabular}
\end{center}
This method is used to simplify truth tables. But be cautious, because we may break the table. For instance, if we swap 1 and X in the second row of the previous table, we have a paradox:
\begin{center}
\begin{tabular}{ c | c | c | c }
\textbf{A} & \textbf{B} & \textbf{C} & \textbf{F}\\ \hline
0 & 0 & X & 0 \\ \hline
0 & X & 1 & 1 \\ \hline
1 & X & X & X \\
\end{tabular}
\end{center}
Notice that the first row could be 001 with a result of 0, but 001 could also be in the second row with a result of 1 | not allowed!
%END%
\end{document}